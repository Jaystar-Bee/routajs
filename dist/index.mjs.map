{"version":3,"sources":["../src/utils/encoding.ts","../src/matcher/index.ts","../src/router.ts","../src/history/base.ts","../src/history/html5.ts","../src/history/hash.ts","../src/history/memory.ts","../src/types.ts"],"sourcesContent":["export function encodeParam(text: string | number): string {\n    return encodeURIComponent('' + text);\n}\n\nexport function decode(text: string | number): string {\n    try {\n        return decodeURIComponent('' + text);\n    } catch (err) {\n        console.warn(`[routajs] Could not decode \"${text}\".`);\n        return '' + text;\n    }\n}\n","import { RouteRecord, RouteRecordRaw, Route, RouteLocationRaw } from '../types';\nimport { decode, encodeParam } from '../utils/encoding';\n\nfunction normalizeRouteRecord(record: RouteRecordRaw): RouteRecord {\n    // Basic regex generation\n    // Supports :param and * (wildcard)\n\n    let pattern = record.path;\n    const paramRegex = /:([a-zA-Z0-9_]+)/g;\n\n    // Replace params with regex\n    pattern = pattern.replace(paramRegex, '(?<$1>[^/]+)');\n\n    // Handle wildcards\n    // * matches everything eagerly\n    pattern = pattern.replace(/\\*/g, '(?<pathMatch>.*)');\n\n    // Ensure we match start and end, and handle trailing slashes optionally\n    // If the pattern doesn't end with a wildcard, we can be strict about trailing slash\n    const endsWithWildcard = record.path.endsWith('*');\n    const regex = new RegExp(`^${pattern}${endsWithWildcard ? '' : '/?'}$`);\n\n    return {\n        ...record,\n        regex,\n        components: record.component ? { default: record.component } : {},\n    };\n}\n\nexport interface RouterMatcher {\n    addRoute(record: RouteRecordRaw): void;\n    resolve(location: RouteLocationRaw, currentLocation: Route): Route;\n    getRoutes(): RouteRecord[];\n}\n\nexport function createRouterMatcher(routes: RouteRecordRaw[]): RouterMatcher {\n    const matchers: RouteRecord[] = [];\n\n    function addRoute(record: RouteRecordRaw, parentPath: string = '') {\n        const fullPath = parentPath + (record.path.startsWith('/') ? record.path : '/' + record.path);\n        // Clean up double slashes just in case, but keep initial slash\n        const cleanedPath = fullPath.replace(/\\/+/g, '/');\n\n        const normalized = normalizeRouteRecord({\n            ...record,\n            path: cleanedPath === '//' ? '/' : cleanedPath\n        });\n\n        matchers.push(normalized);\n\n        if (record.children) {\n            record.children.forEach(child => {\n                addRoute(child, normalized.path === '/' ? '' : normalized.path);\n            });\n        }\n    }\n\n    routes.forEach(r => addRoute(r));\n\n    function resolve(location: RouteLocationRaw, currentLocation: Route): Route {\n        let path: string;\n        let query: Record<string, string | string[]> = {};\n        let hash: string = '';\n\n        if (typeof location === 'string') {\n            const tempUrl = new URL(location, 'http://dummy.com');\n            path = tempUrl.pathname;\n            hash = tempUrl.hash;\n            tempUrl.searchParams.forEach((value, key) => {\n                query[key] = value;\n            });\n        } else {\n            if (location.path) {\n                path = location.path;\n            } else if (location.name) {\n                const matcher = matchers.find(m => m.name === location.name);\n                if (matcher) {\n                    path = matcher.path;\n                    if (location.params) {\n                        for (const key in location.params) {\n                            path = path.replace(`:${key}`, encodeParam(location.params[key]));\n                        }\n                    }\n                } else {\n                    throw new Error(`Route with name '${String(location.name)}' not found`);\n                }\n            } else {\n                path = currentLocation.path;\n            }\n\n            if (location.query) query = location.query;\n            if (location.hash) hash = location.hash;\n        }\n\n        let matchedRecord: RouteRecord | undefined;\n        let params: Record<string, string> = {};\n\n        for (const matcher of matchers) {\n            const match = matcher.regex.exec(path);\n            if (match) {\n                matchedRecord = matcher;\n                params = match.groups || {};\n                break;\n            }\n        }\n\n        if (!matchedRecord) {\n            return {\n                fullPath: path + (hash || ''),\n                path,\n                params: {},\n                query,\n                hash,\n                matched: [],\n                meta: {},\n                previousFullPath: null\n            };\n        }\n\n        // Decode params\n        Object.keys(params).forEach(key => {\n            params[key] = decode(params[key]);\n        });\n\n        const queryString = Object.keys(query).length ? '?' + new URLSearchParams(query as any).toString() : '';\n\n        return {\n            fullPath: path + queryString + (hash || ''),\n            path,\n            params,\n            query,\n            hash,\n            name: matchedRecord.name,\n            matched: [matchedRecord],\n            meta: matchedRecord.meta || {},\n            previousFullPath: null\n        };\n    }\n\n    return {\n        addRoute,\n        resolve,\n        getRoutes: () => matchers\n    };\n}\n\n","import { RouterHistory, Route, RouteLocationRaw, NavigationGuard, RouteRecordRaw } from './types';\nimport { RouterMatcher, createRouterMatcher } from './matcher/index';\n\nexport interface RouterOptions {\n    history: RouterHistory;\n    routes: RouteRecordRaw[];\n}\n\nexport class Router {\n    private history: RouterHistory;\n    private matcher: RouterMatcher;\n    private currentRoute: Route;\n    private previousRoute: Route | null = null;\n    private beforeGuards: NavigationGuard[] = [];\n    private afterGuards: ((to: Route, from: Route) => void)[] = [];\n\n    // Reactive listeners (simple pub/sub for UI frameworks to hook into)\n    private routeListeners: ((route: Route) => void)[] = [];\n\n    constructor(options: RouterOptions) {\n        this.history = options.history;\n        this.matcher = createRouterMatcher(options.routes);\n\n        // Initial route\n        this.currentRoute = this.matcher.resolve(this.history.location, {\n            fullPath: '/',\n            path: '/',\n            params: {},\n            query: {},\n            hash: '',\n            matched: [],\n            meta: {},\n            previousFullPath: null\n        });\n\n        // Listen to history changes\n        this.history.listen((toLocation, _fromLocation, info) => {\n            this.handleNavigation(toLocation, info.direction);\n        });\n    }\n\n    get current() {\n        return this.currentRoute;\n    }\n\n    get previous() {\n        return this.previousRoute;\n    }\n\n    // Public API to resolve a route without navigating\n    resolve(to: RouteLocationRaw): Route {\n        return this.matcher.resolve(to, this.currentRoute);\n    }\n\n    push(to: RouteLocationRaw) {\n        return this.navigate(to, false);\n    }\n\n    replace(to: RouteLocationRaw) {\n        return this.navigate(to, true);\n    }\n\n    go(delta: number) {\n        this.history.go(delta);\n    }\n\n    back() {\n        this.go(-1);\n    }\n\n    forward() {\n        this.go(1);\n    }\n\n    beforeEach(guard: NavigationGuard) {\n        this.beforeGuards.push(guard);\n    }\n\n    afterEach(guard: (to: Route, from: Route) => void) {\n        this.afterGuards.push(guard);\n    }\n\n    // Internal navigation logic\n    private async navigate(to: RouteLocationRaw, replace: boolean): Promise<any> {\n        const targetRoute = this.matcher.resolve(to, this.currentRoute);\n        const fromRoute = this.currentRoute;\n\n        // Run Guards\n        try {\n            for (const guard of this.beforeGuards) {\n                await new Promise<void>((resolve, reject) => {\n                    const next = (nextArg: any) => {\n                        if (nextArg === false) {\n                            reject(new Error('Navigation cancelled'));\n                        } else if (typeof nextArg === 'string' || (typeof nextArg === 'object' && nextArg !== null)) {\n                            // Redirect\n                            reject({ redirect: nextArg });\n                        } else {\n                            resolve();\n                        }\n                    };\n                    // guard(to, from, next)\n                    const res = guard(targetRoute, fromRoute, next);\n                    if (res && typeof (res as Promise<any>).then === 'function') {\n                        // It's a promise that didn't use next? \n                        // For simplicity, we assume guards use 'next' or return async boolean/void?\n                        // Vue router is shifting to return values. Let's support 'next' pattern primarily as typings defined.\n                    }\n                });\n            }\n        } catch (error: any) {\n            if (error && error.redirect) {\n                return this.push(error.redirect);\n            }\n            return Promise.reject(error);\n        }\n\n        // Commit navigation\n        if (replace) {\n            this.history.replace(targetRoute.fullPath);\n        } else {\n            this.history.push(targetRoute.fullPath);\n        }\n\n        this.updateRoute(targetRoute);\n    }\n\n    private handleNavigation(location: string, _direction: string) {\n        const targetRoute = this.matcher.resolve(location, this.currentRoute);\n        this.updateRoute(targetRoute);\n    }\n\n    private updateRoute(newRoute: Route) {\n        const from = this.currentRoute;\n        this.previousRoute = from;\n\n        // Update the new route with previousFullPath\n        newRoute.previousFullPath = from.fullPath;\n\n        this.currentRoute = Object.freeze(newRoute);\n\n        // Run After Hooks\n        this.afterGuards.forEach(guard => guard(newRoute, from));\n\n        // Notify listeners\n        this.routeListeners.forEach(cb => cb(newRoute));\n    }\n\n    // Method to allow frameworks to listen to changes\n    listen(cb: (route: Route) => void) {\n        this.routeListeners.push(cb);\n    }\n}\n\nexport function createRouter(options: RouterOptions): Router {\n    return new Router(options);\n}\n","import { RouterHistory, HistoryLocation } from '../types';\n\nexport function normalizeBase(base?: string): string {\n    if (!base) {\n        if (typeof window !== 'undefined' && window.document) {\n            const baseEl = document.querySelector('base');\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\n        } else {\n            base = '/';\n        }\n    }\n    if (!base.startsWith('/')) {\n        base = '/' + base;\n    }\n    return base.replace(/\\/$/, '') || '/';\n}\n\nexport function createCurrentLocation(base: string, location: Location): HistoryLocation {\n    const { pathname, search, hash } = location;\n    // allow for id-only navigation\n    if (base.indexOf('#') > -1 && pathname.indexOf('#') === -1) {\n        return pathname + search + hash;\n    }\n    // strip base\n    if (pathname.indexOf(base) === 0) {\n        return pathname.slice(base.length) + search + hash;\n    }\n    return pathname + search + hash;\n}\n","import { RouterHistory, HistoryLocation } from '../types';\nimport { normalizeBase, createCurrentLocation } from './base';\n\nexport function createWebHistory(base?: string): RouterHistory {\n    const normalizedBase = normalizeBase(base);\n    const history = window.history;\n    let listeners: ((to: HistoryLocation, from: HistoryLocation, info: { direction: 'back' | 'forward' | 'unknown' }) => void)[] = [];\n\n    const currentLocation = () => {\n        return createCurrentLocation(normalizedBase, window.location);\n    };\n\n    const handlePopState = ({ state }: PopStateEvent) => {\n        const to = currentLocation();\n        const from = state ? state.current : currentLocation();\n\n        // In a real router, we'd use the key to determine direction.\n        // For now, we just notify.\n        listeners.forEach(listener => listener(to, from, { direction: 'unknown' }));\n    };\n\n    window.addEventListener('popstate', handlePopState);\n\n    // Helper to persist state if needed\n    function changeLocation(to: HistoryLocation, replace: boolean) {\n        const url = normalizedBase + (to === '/' ? '' : to);\n        const state = {\n            current: to,\n            key: performance.now().toFixed(3) // Simple unique key\n        };\n\n        try {\n            if (replace) {\n                history.replaceState(state, '', url);\n            } else {\n                history.pushState(state, '', url);\n            }\n        } catch (err) {\n            window.location[replace ? 'replace' : 'assign'](url);\n        }\n    }\n\n    return {\n        base: normalizedBase,\n        get location() {\n            return currentLocation();\n        },\n        push(to, _data) {\n            changeLocation(to, false);\n        },\n        replace(to, _data) {\n            changeLocation(to, true);\n        },\n        go(delta) {\n            history.go(delta);\n        },\n        listen(callback) {\n            listeners.push(callback);\n            return () => {\n                const index = listeners.indexOf(callback);\n                if (index > -1) listeners.splice(index, 1);\n            };\n        },\n        createHref(location) {\n            return normalizedBase + location;\n        },\n    };\n}\n\n","import { RouterHistory } from '../types';\nimport { createWebHistory } from './html5';\n\nexport function createWebHashHistory(base?: string): RouterHistory {\n    // Hash history is essentially browser history but with a forced base and #\n    // This is a naive implementation; production might need more handling of the hash sign itself\n\n    // usually base for hash history is just window.location.pathname + '#'\n    // but if user provides a base, we prepend it.\n\n    // Real implementation of hash history often manipulates window.location.hash directly\n    // and listens to hashchange. However, modern browsers support pushState with hash too.\n    // For simplicity and robustness, standard 'vue-router' uses pushState/replaceState \n    // even for hash mode if available, but falls back.\n    // Here let's stick to true hashchange for maximum compatibility if we want \"hash\" mode.\n\n    const formattedBase = (base || '') + '#';\n\n    return createWebHistory(formattedBase);\n}\n","import { RouterHistory, HistoryLocation } from '../types';\n\nexport function createMemoryHistory(base: string = ''): RouterHistory {\n    let queue: HistoryLocation[] = ['/'];\n    let position = 0;\n    let listeners: ((to: HistoryLocation, from: HistoryLocation, info: { direction: 'back' | 'forward' | 'unknown' }) => void)[] = [];\n\n    return {\n        base,\n        get location() {\n            return queue[position];\n        },\n        push(to, _data) {\n            position++;\n            if (position < queue.length) {\n                queue.splice(position);\n            }\n            queue.push(to);\n        },\n        replace(to, _data) {\n            queue.splice(position, 1, to);\n        },\n        go(delta) {\n            const from = queue[position];\n            const newPosition = position + delta;\n            if (newPosition >= 0 && newPosition < queue.length) {\n                position = newPosition;\n                const to = queue[position];\n                // Notify listeners as memory history doesn't trigger popstate\n                listeners.forEach(listener => listener(to, from, { direction: delta > 0 ? 'forward' : 'back' }));\n            }\n        },\n        listen(callback) {\n            listeners.push(callback);\n            return () => {\n                const index = listeners.indexOf(callback);\n                if (index > -1) listeners.splice(index, 1);\n            };\n        },\n        createHref(location) {\n            return base + location;\n        },\n    };\n}\n","/**\n * Represents a route location with all its details.\n */\nexport interface Route {\n    fullPath: string;\n    path: string;\n    params: Record<string, string>;\n    query: Record<string, string | string[]>;\n    hash: string;\n    name?: string | symbol;\n    meta: Record<string | number | symbol, unknown>;\n    matched: RouteRecord[]; // Records that matched this route\n    previousFullPath: string | null; // The full path of the previous route\n}\n\n/**\n * Input for programmatic navigation.\n * Can be a string path or an object.\n */\nexport type RouteLocationRaw = string | {\n    path?: string;\n    name?: string | symbol;\n    params?: Record<string, string>;\n    query?: Record<string, string | string[]>;\n    hash?: string;\n    replace?: boolean;\n}\n\n/**\n * A user-defined route record.\n */\nexport interface RouteRecordRaw {\n    path: string;\n    name?: string | symbol;\n    component?: any; // Component type is generic as this is framework-agnostic\n    children?: RouteRecordRaw[];\n    meta?: Record<string | number | symbol, unknown>;\n    beforeEnter?: NavigationGuard;\n}\n\n/**\n * Normalized internal route record.\n */\nexport interface RouteRecord extends RouteRecordRaw {\n    regex: RegExp;\n    components: Record<string, any>;\n    aliasOf?: RouteRecord;\n}\n\nexport interface NavigationGuardNext {\n    (to?: RouteLocationRaw | false | void): void;\n}\n\nexport interface NavigationGuard {\n    (to: Route, from: Route, next: NavigationGuardNext): void | Promise<void | boolean | RouteLocationRaw>;\n}\n\nexport type HistoryLocation = string;\n\nexport enum HistoryType {\n    BROWSER = 'browser',\n    HASH = 'hash',\n    MEMORY = 'memory'\n}\n\nexport interface RouterHistory {\n    readonly base: string;\n    readonly location: HistoryLocation;\n    push(to: HistoryLocation, data?: any): void;\n    replace(to: HistoryLocation, data?: any): void;\n    go(delta: number): void;\n    listen(callback: (to: HistoryLocation, from: HistoryLocation, info: { direction: 'back' | 'forward' | 'unknown' }) => void): () => void;\n    createHref(location: HistoryLocation): string;\n}\n"],"mappings":"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","names":["HistoryType"]}